<< 아날로그  -> 디지털화  >>
아날로그  -> [ 샘플링  -> 양자화  -> 이진화  ]   -> 디지털화
   - 샘플링 : 연속적인 아날로그 신호를 일정한 시간 간격으로 샘플링 하는 작업 후 이산화 작업
   - 양자화 : 샘플링된 값들을 특정한 정밀도와 범위를 가진 숫자값들로 변환 (연속적인 아날로그 값을 디지털로 근사화 시킨다)
   - 이진화 : 양자화된 값을 이진코드로 변환해서 디지털 값으로 리턴

<<  디지털화 ->  아날로그   >>
복호화  :  디지털 데이터를 이진화  -> 양자화  ->  신호복원

1. 이미지 양자화   : 연속적인 이미지 픽셀 값을 유한한 범위의 이산 값으로 매핑하는 과정을 의미
 - 목적 :  표현 가능한 픽셀 값의 수를 줄여 저장 공간이나 전송 대역폭을 절약하기 위한 방법이다.
 - 균일과 비균일로 이루어진다.
     [균일 양자화]: 모든 픽셀 값의 범위를 동일한 간격으로 나눈다.
     ex) 0~255 사이의 그레이스케일 값 ->  0, 51, 102, ..., 255과 같은 값으로 매핑
         quantized_image = (image / 51) * 51
     [비균일 양자화]: 이미지의 통계적 또는 심리 시각적 특성을 고려하여 픽셀 값의 범위를 나눈다.
       ex) K-means 양자화
       quantized_pixels = kmeans.cluster_centers_[kmeans.labels_].reshape(image.shape)
       quantized_image = np.array(quantized_pixels, dtype=np.uint8)

 - JPEG 압축에서의 양자화는 Discrete Cosine Transform (DCT)를 통해 얻은 계수를 일정한 값으로 나누는 과정을 포함한다.
      cv2.imwrite("compressed_image.jpg", image, [cv2.IMWRITE_JPEG_QUALITY, 10])
      양자화의 정도는 JPEG 품질 설정에 따라 다르며 품질이 높으면 양자화는 덜 심하고, 품질이 낮으면 양자화는 더 심해진다.
       DCT _ 데이터압축 : 소리, 이미지를 주파수 도메인 으로 변환 후 데이터의 주요 주파수 성분을 사용할 수 있도록 촛점을 맞춘다.
       아날로그 주파수분리 : FT
================================================================================================
 * 양자화를 하는 이유 ?
   ===> 이미지나 신호에서 정보를 유지하면서 크기를 줄이는데 사용된다.
 * 양자화 종류
    - K-means 양자화: 이미지의 각 픽셀 값을 k개의 중심 값 중 하나로 매핑 양자화(컬러 양자화)
    - Vector Quantization (VQ): K-means의 일반화된 형태로, 여러 차원의 데이터 포인트를 양자화( +)

   -  영역 기반 양자화 (Region-based Quantization): 이미지를 여러 영역으로 나눈 후, 각 영역 내에서 양자화를 적용
         ex)cv2.split()
   -  데이터베이스 양자화: 이미지의 픽셀 값을 미리 정의된 몇 가지 값 중 하나로 대체하는 방법 LUT(Look-Up Table)를 사용
        ex)cv2.LUT()
   -  차등 양자화 (Differential Quantization): 픽셀 값 대신 픽셀 값의 차이를 양자화
        ex) numpy.diff() ,  numpy.cumsum()

   -  Scalable Quantization: 다양한 해상도에  동작이 잘 되도록 설계된 양자화(+)

   -   Binarization: 픽셀 값을 두 가지 값 중 하나만들어 이미지를 단순화하여 계산을 빠르게 하거나, 특정 정보를 추출할 때 사용
        ex)cv2.threshold() 또는 cv2.adaptiveThreshold()

   - Simple Quantization :값을 일정 범위로 나눈 후 해당 범위의 평균 값이나 중앙 값으로 대체 (+)

 * 주의: 양자화는 이미지의 각 픽셀 값이 가질 수 있는 수치 범위를 줄이는 과정이므로 [shape는 영향을 미치지 않는다]
 ===================================================================================================

2. 색상공간 변경
c_color_space.py  : cvtColor 함수를 사용하면 이미지의 색상 공간을 다양하게 변경할 수 있다.
BGR to Gray: 컬러 이미지를 흑백 이미지로 변환
BGR to HSV: BGR 색상 공간에서 HSV 색상 공간으로 변환
BGR to YCrCb: BGR 색상 공간에서 YCrCb 색상 공간으로 변환

  - HSV는 "Hue, Saturation, Value"의 약자로, 색상(Hue), 채도(Saturation), 밝기(Value)를 나타내는 색공간 색표현 모델
  -  BT.601   = RGB에서 Y 값을 산출하는 공식  = RGB 컬러 이미지를 흑백으로 변환하는 경우, 신호 Y 값을 산출
      #   Y   =  0.299* R    +    0.587 *  G     +  0.114 *  B
  -  BT.601 : 일반적인 사람의 시각 특성을 고려한 것으로 가장 밝게 느껴 지는 G(녹색)의 계수가 커지는 것을 확인

3. 이미지 결합
이미지 결합 = 세로 연결 / 가로 연결 / 바둑판 연결
cv.vconcat() - 폭이 동일한 이미지를 세로로 연결
            - 같은 이미지를 반복 세로 연결
            - 폭이 서로 다른 이미지도 세로로 연결
  주의점  : 같은  폭   ,  같은 채널 수  , 데이터 타입 일치 , None(오류)
src[i].dims <= 2 && src[i].cols == src[0].cols && src[i].type() == src[0].type()


cv.hconcat() - 높이가 동일한 이미지를 가로로 연결
            - 같은 이미지를 반복 가로 연결
            - 높이가 서로 다른 이미지도 가로 연결
   주의점  : 같은  높이  ,  같은 채널 수  , 데이터 타입 일치 , None(오류)
   src[i].dims <= 2 && src[i].rows == src[0].rows && src[i].type() == src[0].type()


np.tile() : 같은 이미지를 반복 정렬

=============================================================================================
[질문] 자율주행차량의 카메라에 보이는 물체랑 측정하는 카메라 위치와의 거리도 측정이 가능한지 궁금합니다
[답변]  스테레오카메라 (물체거리 측정 )  /ToF(빛 속도로 거리 측정) / LiDAR 시스템 (레이저 빔 )  : 3D map
  모노 카메라  (싱글카메라 렌즈 )
========================================================================================

<< HSV(색상, 채도 , 명도)로 CV에서 프로세싱 하는 목적 >>
1. 색상 = 단일 채널 색상 , 특정색의 객체를 추적하거나 배경에서 분리하는 작업
2. 채도, 명도 =  이미지 색상 강도 , 밝기 변화
3. 불변성 확보 = 조명변화는 불변 , 야외환경 또는 다양한 조명상태의 응용프로그램
4. 색상 기반 필터링 사용  = 특정 피부색 , 특정 배경 감지 분리


[질문] 자율주행차량의 카메라에 보이는 물체랑 측정하는 카메라 위치와의 거리도 측정이 가능한지 궁금합니다
[답변] 스테레오 카메라 (물체거리 측정) / ToF(빛 속도로 거리 측정) / LiDAR(레이저 빔)  : 3D map 모노 카메라(싱글카메라 렌즈)









